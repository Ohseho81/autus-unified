<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>âš›ï¸ AUTUS Economic Physics Engine - QCF Edition</title>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --quantum-glow: rgba(0, 255, 136, 0.8);
      --chaos-glow: rgba(255, 204, 0, 0.8);
      --entangle-glow: rgba(153, 102, 255, 0.8);
      --entropy-glow: rgba(255, 68, 102, 0.8);
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000011;
      color: #fff;
      overflow: hidden;
    }
    
    /* ë©”ì¸ ìº”ë²„ìŠ¤ */
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: grab;
    }
    
    #canvas.dragging { cursor: grabbing; }
    #canvas.selecting { cursor: crosshair; }
    
    /* í—¤ë” - Economic Physics Engine */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 17, 0.98) 0%, transparent 100%);
      padding: 16px 24px;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      color: #00ff88;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .header-left .philosophy {
      color: #444;
      font-size: 9px;
      margin-top: 4px;
      letter-spacing: 1px;
      font-style: italic;
    }
    
    .header-left .musk-quote {
      color: #666;
      font-size: 10px;
      margin-top: 6px;
      max-width: 400px;
      line-height: 1.4;
      border-left: 2px solid #333;
      padding-left: 10px;
    }
    
    /* KPI íŒ¨ë„ */
    .kpi-panel {
      display: flex;
      gap: 20px;
    }
    
    .kpi-item {
      text-align: right;
      min-width: 100px;
    }
    
    .kpi-label {
      color: #555;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      margin-top: 2px;
    }
    
    .positive { color: #00ff88; }
    .negative { color: #ff4466; }
    .neutral { color: #ffcc00; }
    .quantum { color: #9966ff; }
    
    /* QCF ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
    .qcf-panel {
      position: absolute;
      top: 120px;
      left: 20px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(153, 102, 255, 0.4);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      width: 260px;
    }
    
    .panel-title {
      color: #9966ff;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .qcf-state {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .state-btn {
      flex: 1;
      padding: 8px 4px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #888;
      font-size: 9px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    
    .state-btn:hover { background: rgba(255, 255, 255, 0.1); }
    .state-btn.active {
      background: rgba(153, 102, 255, 0.2);
      border-color: #9966ff;
      color: #9966ff;
    }
    
    .zoom-info {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      padding: 10px;
      margin-top: 12px;
    }
    
    .zoom-label {
      color: #666;
      font-size: 10px;
    }
    
    .zoom-value {
      font-size: 14px;
      font-weight: bold;
      color: #00ccff;
    }
    
    .zoom-level {
      font-size: 10px;
      color: #888;
      margin-top: 4px;
    }
    
    /* ë¬¼ë¦¬ íš¨ê³¼ íŒ¨ë„ */
    .physics-panel {
      position: absolute;
      top: 120px;
      right: 20px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 255, 136, 0.3);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      width: 280px;
    }
    
    .physics-effect {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .physics-effect:hover {
      background: rgba(255, 255, 255, 0.06);
    }
    
    .physics-effect.active {
      border: 1px solid rgba(0, 255, 136, 0.4);
    }
    
    .effect-icon {
      font-size: 20px;
      width: 32px;
      text-align: center;
    }
    
    .effect-info {
      flex: 1;
    }
    
    .effect-name {
      font-size: 12px;
      font-weight: bold;
    }
    
    .effect-desc {
      font-size: 9px;
      color: #666;
      margin-top: 2px;
    }
    
    .effect-toggle {
      width: 36px;
      height: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      position: relative;
      transition: all 0.2s;
    }
    
    .effect-toggle::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      background: #666;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: all 0.2s;
    }
    
    .physics-effect.active .effect-toggle {
      background: rgba(0, 255, 136, 0.3);
    }
    
    .physics-effect.active .effect-toggle::after {
      background: #00ff88;
      left: 18px;
    }
    
    /* ì˜ˆì¸¡ íŒ¨ë„ */
    .predict-panel {
      position: absolute;
      bottom: 100px;
      right: 20px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(255, 204, 0, 0.3);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      width: 260px;
    }
    
    .predict-item {
      margin-bottom: 12px;
    }
    
    .predict-label {
      color: #888;
      font-size: 10px;
      text-transform: uppercase;
    }
    
    .predict-value {
      font-size: 20px;
      font-weight: bold;
      margin-top: 4px;
    }
    
    .predict-delta {
      font-size: 11px;
      margin-top: 2px;
    }
    
    .best-team {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }
    
    .team-badge {
      background: rgba(0, 255, 136, 0.2);
      border: 1px solid rgba(0, 255, 136, 0.4);
      border-radius: 12px;
      padding: 4px 10px;
      font-size: 10px;
      color: #00ff88;
    }
    
    /* ë“œë˜ê·¸ ì…ë ¥ íŒ¨ë„ */
    .drag-panel {
      position: absolute;
      bottom: 100px;
      left: 20px;
      background: rgba(0, 0, 17, 0.95);
      border: 1px solid rgba(0, 204, 255, 0.3);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      width: 260px;
    }
    
    .input-type-row {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .input-btn {
      flex: 1;
      padding: 10px 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #888;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .input-btn:hover { background: rgba(255, 255, 255, 0.1); }
    .input-btn.active {
      background: rgba(0, 204, 255, 0.2);
      border-color: #00ccff;
      color: #00ccff;
    }
    
    .input-hint {
      color: #666;
      font-size: 10px;
      line-height: 1.5;
      padding: 10px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 6px;
    }
    
    /* í´ëŸ¬ìŠ¤í„° ì•¡ì…˜ */
    .cluster-actions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    
    .action-btn {
      padding: 12px 24px;
      background: rgba(0, 0, 17, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 24px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .action-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .action-btn.primary {
      background: rgba(0, 255, 136, 0.2);
      border-color: rgba(0, 255, 136, 0.5);
    }
    
    .action-btn.danger {
      background: rgba(255, 68, 102, 0.2);
      border-color: rgba(255, 68, 102, 0.5);
    }
    
    /* ìƒíƒœ ë°” */
    .status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 17, 0.95);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #ff4466;
    }
    
    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }
    
    /* ë…¸ë“œ ì •ë³´ íŒì—… */
    .node-popup {
      position: absolute;
      display: none;
      background: rgba(0, 0, 17, 0.98);
      border: 1px solid rgba(0, 255, 136, 0.5);
      border-radius: 12px;
      padding: 16px;
      z-index: 200;
      min-width: 220px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }
    
    .node-popup.visible { display: block; }
    
    .popup-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 12px;
    }
    
    .popup-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 204, 255, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .popup-name {
      font-size: 16px;
      font-weight: bold;
    }
    
    .popup-type {
      font-size: 10px;
      color: #666;
    }
    
    .popup-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    .popup-row .label { color: #666; }
    .popup-row .value { font-weight: bold; }
    
    /* ì–‘ì íš¨ê³¼ ì‹œê°í™” */
    @keyframes quantum-pulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    
    @keyframes chaos-flutter {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(2px, -2px); }
      50% { transform: translate(-2px, 2px); }
      75% { transform: translate(2px, 2px); }
    }
    
    @keyframes entangle-sync {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* ì„ íƒ ë°•ìŠ¤ */
    .selection-box {
      position: absolute;
      border: 2px dashed rgba(0, 204, 255, 0.8);
      background: rgba(0, 204, 255, 0.1);
      pointer-events: none;
      z-index: 150;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="selection-box" id="selection-box"></div>
  
  <!-- í—¤ë” -->
  <div class="header">
    <div class="header-left">
      <h1>âš›ï¸ AUTUS Economic Physics Engine</h1>
      <div class="philosophy">QCF Edition â€¢ First Principles â€¢ ì‚¬ëŒ+ëˆë§Œ â€¢ ì˜ë¯¸ ì œê±° = ìŠ¤ì¼€ì¼ ê·¹ëŒ€í™”</div>
      <div class="musk-quote">
        "ì´ê±´ ì‹œê°í™”ê°€ ì•„ë‹ˆë¼ ì‹¤ì‹œê°„ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„ì´ë‹¤. 
        ì§€êµ¬ë¥¼ ë…¸ë“œì™€ ì—£ì§€ë¡œ í™˜ì›í–ˆë‹¤." â€” Elon Style
      </div>
    </div>
    <div class="kpi-panel">
      <div class="kpi-item">
        <div class="kpi-label">Net Coin (7D)</div>
        <div class="kpi-value positive" id="kpi-net">â‚©289M</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">Entropy</div>
        <div class="kpi-value neutral" id="kpi-entropy">0.02</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">Velocity</div>
        <div class="kpi-value" style="color: #00ccff;" id="kpi-velocity">â‚©61K/m</div>
      </div>
      <div class="kpi-item">
        <div class="kpi-label">Nodes</div>
        <div class="kpi-value quantum" id="kpi-nodes">5</div>
      </div>
    </div>
  </div>
  
  <!-- QCF ì»¨íŠ¸ë¡¤ -->
  <div class="qcf-panel">
    <div class="panel-title">ğŸŒŒ Quantum Cluster Flow</div>
    <div class="qcf-state">
      <button class="state-btn" data-state="quantum">
        ğŸŒ€<br>Quantum
      </button>
      <button class="state-btn active" data-state="observe">
        ğŸ‘ï¸<br>Observe
      </button>
      <button class="state-btn" data-state="cluster">
        ğŸ”·<br>Cluster
      </button>
    </div>
    <div style="font-size: 10px; color: #666; line-height: 1.5;">
      <strong>Quantum</strong>: ë¯¸ê´€ì¸¡ ìƒíƒœ (ë©”íƒ€ë°ì´í„°ë§Œ)<br>
      <strong>Observe</strong>: ê´€ì¸¡ ì˜ì—­ ì‹¤ì²´í™”<br>
      <strong>Cluster</strong>: í´ëŸ¬ìŠ¤í„° ë¶•ê´´ ëª¨ë“œ
    </div>
    <div class="zoom-info">
      <div class="zoom-label">í˜„ì¬ ì¤Œ ë ˆë²¨</div>
      <div class="zoom-value" id="zoom-value">Level 3</div>
      <div class="zoom-level" id="zoom-level">ê°œì¸ ë ˆë²¨ (1-30 ë…¸ë“œ)</div>
    </div>
  </div>
  
  <!-- ë¬¼ë¦¬ íš¨ê³¼ íŒ¨ë„ -->
  <div class="physics-panel">
    <div class="panel-title" style="color: #00ff88;">âš¡ Physics Effects</div>
    
    <div class="physics-effect active" data-effect="superposition">
      <span class="effect-icon">ğŸŒ€</span>
      <div class="effect-info">
        <div class="effect-name">Quantum Superposition</div>
        <div class="effect-desc">ë‹¤ì¤‘ ìƒíƒœ ì¤‘ì²© â†’ ì•¡ì…˜ ì‹œ ë¶•ê´´</div>
      </div>
      <div class="effect-toggle"></div>
    </div>
    
    <div class="physics-effect active" data-effect="chaos">
      <span class="effect-icon">ğŸ¦‹</span>
      <div class="effect-info">
        <div class="effect-name">Chaos (Butterfly)</div>
        <div class="effect-desc">ì‘ì€ ë³€í™” â†’ ì§€ìˆ˜ì  ëˆ ë³€ë™</div>
      </div>
      <div class="effect-toggle"></div>
    </div>
    
    <div class="physics-effect" data-effect="entropy">
      <span class="effect-icon">ğŸ”¥</span>
      <div class="effect-info">
        <div class="effect-name">Entropy Correction</div>
        <div class="effect-desc">ì‹œë„ˆì§€ ë‚®ìœ¼ë©´ ë¹„ìœ¨ í•˜ë½</div>
      </div>
      <div class="effect-toggle"></div>
    </div>
    
    <div class="physics-effect" data-effect="entangle">
      <span class="effect-icon">ğŸ”—</span>
      <div class="effect-info">
        <div class="effect-name">Quantum Entanglement</div>
        <div class="effect-desc">ê±°ë¦¬ ë¬´ê´€ ì¦‰ì‹œ ë™ê¸°í™”</div>
      </div>
      <div class="effect-toggle"></div>
    </div>
    
    <div class="physics-effect" data-effect="relativity">
      <span class="effect-icon">ğŸŒŠ</span>
      <div class="effect-info">
        <div class="effect-name">Action Relativity</div>
        <div class="effect-desc">ì—°ê²° ìƒëŒ€ì— ë”°ë¼ ë¹„ìœ¨ ë‹¤ë¦„</div>
      </div>
      <div class="effect-toggle"></div>
    </div>
  </div>
  
  <!-- ì˜ˆì¸¡ íŒ¨ë„ -->
  <div class="predict-panel">
    <div class="panel-title" style="color: #ffcc00;">ğŸ”® Rolling Prediction (7D)</div>
    
    <div class="predict-item">
      <div class="predict-label">Predicted Net</div>
      <div class="predict-value positive" id="pred-net">â‚©289M</div>
      <div class="predict-delta positive" id="pred-net-delta">â†‘ +15%</div>
    </div>
    
    <div class="predict-item">
      <div class="predict-label">Predicted Entropy</div>
      <div class="predict-value neutral" id="pred-entropy">0.02</div>
    </div>
    
    <div class="predict-item">
      <div class="predict-label">Best Team</div>
      <div class="best-team" id="pred-team">
        <span class="team-badge">ì˜¤ì„¸í˜¸</span>
        <span class="team-badge">ê¹€ê²½í¬</span>
        <span class="team-badge">ì˜¤ì„ ìš°</span>
      </div>
      <div style="margin-top: 8px; font-size: 11px; color: #888;">
        Score: <span id="pred-score" style="color: #00ff88;">â‚©12.1M</span>
      </div>
    </div>
  </div>
  
  <!-- ë“œë˜ê·¸ ì…ë ¥ -->
  <div class="drag-panel">
    <div class="panel-title" style="color: #00ccff;">ğŸ–±ï¸ Physics Input (Drag)</div>
    <div class="input-type-row">
      <button class="input-btn active" data-input="swap">
        ğŸ‘¥ SWAP<br><span style="font-size: 8px;">íŒ€ êµì²´</span>
      </button>
      <button class="input-btn" data-input="alloc">
        â±ï¸ ALLOC<br><span style="font-size: 8px;">ì‹œê°„ ë°°ë¶„</span>
      </button>
      <button class="input-btn" data-input="group">
        ğŸ”· GROUP<br><span style="font-size: 8px;">í´ëŸ¬ìŠ¤í„°</span>
      </button>
    </div>
    <div class="input-hint" id="input-hint">
      ë…¸ë“œë¥¼ ë“œë˜ê·¸í•˜ì—¬ íŒ€ êµì²´.<br>
      ë“œë˜ê·¸ ê±°ë¦¬ = ë¬¼ë¦¬ ì…ë ¥ í¬ê¸°.<br>
      ì˜ˆì¸¡ ì¦‰ì‹œ ê°±ì‹  (1ì´ˆ ë‚´).
    </div>
  </div>
  
  <!-- í´ëŸ¬ìŠ¤í„° ì•¡ì…˜ -->
  <div class="cluster-actions">
    <button class="action-btn" id="btn-select">
      âœ¨ ì„ íƒ ëª¨ë“œ
    </button>
    <button class="action-btn primary" id="btn-group">
      ğŸ”· ê·¸ë£¹ ìƒì„±
    </button>
    <button class="action-btn" id="btn-ungroup">
      ğŸ“¤ ê·¸ë£¹ í•´ì œ
    </button>
    <button class="action-btn danger" id="btn-delete">
      ğŸ—‘ï¸ CUT (ì‚­ì œ)
    </button>
    <button class="action-btn" id="btn-automate">
      âš¡ LINK (ìë™í™”)
    </button>
  </div>
  
  <!-- ìƒíƒœ ë°” -->
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot" id="ws-dot"></div>
      <span id="ws-status">ì—°ê²° ì¤‘...</span>
    </div>
    <div class="status-item">
      <span>QCF State: <span id="qcf-state-text">OBSERVE</span></span>
    </div>
    <div class="status-item">
      <span>Loaded: <span id="loaded-nodes">5</span> nodes / <span id="loaded-links">8</span> links</span>
    </div>
    <div class="status-item">
      <span>AUTUS Economic Physics Engine v1.0 â€¢ First Principles â€¢ V = Î£ Î¦_ij</span>
    </div>
  </div>
  
  <!-- ë…¸ë“œ íŒì—… -->
  <div class="node-popup" id="node-popup">
    <div class="popup-header">
      <div class="popup-avatar" id="popup-avatar">ğŸ‘¤</div>
      <div>
        <div class="popup-name" id="popup-name">Name</div>
        <div class="popup-type" id="popup-type">Type</div>
      </div>
    </div>
    <div class="popup-row">
      <span class="label">Total Coin</span>
      <span class="value positive" id="popup-coin">â‚©0</span>
    </div>
    <div class="popup-row">
      <span class="label">Velocity</span>
      <span class="value" style="color: #00ccff;" id="popup-velocity">â‚©0/min</span>
    </div>
    <div class="popup-row">
      <span class="label">Quantum State</span>
      <span class="value quantum" id="popup-quantum">Observed</span>
    </div>
    <div class="popup-row">
      <span class="label">Synergy Links</span>
      <span class="value" id="popup-links">0</span>
    </div>
    <div class="popup-row">
      <span class="label">Chaos Factor</span>
      <span class="value neutral" id="popup-chaos">1.0x</span>
    </div>
  </div>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìƒíƒœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const state = {
      // QCF ìƒíƒœ
      qcfState: 'observe', // quantum | observe | cluster
      zoom: 3,
      
      // ë¬¼ë¦¬ íš¨ê³¼
      effects: {
        superposition: true,
        chaos: true,
        entropy: false,
        entangle: false,
        relativity: false
      },
      
      // ì…ë ¥ íƒ€ì…
      inputType: 'swap',
      
      // ë…¸ë“œ/ë§í¬
      nodes: [],
      links: [],
      clusters: [],
      
      // ì„ íƒ
      selectedNodes: new Set(),
      isSelecting: false,
      selectionStart: null,
      
      // ë“œë˜ê·¸
      isDragging: false,
      dragNode: null,
      dragStart: { x: 0, y: 0 },
      
      // íŒ¬/ì¤Œ
      pan: { x: 0, y: 0 },
      scale: 1,
      
      // KPI
      kpi: {
        net_7d_pred: 289000000,
        entropy_7d_pred: 0.02,
        velocity_7d_pred: 61458,
        best_team: ['ì˜¤ì„¸í˜¸', 'ê¹€ê²½í¬', 'ì˜¤ì„ ìš°'],
        best_team_score: 12112286
      },
      
      // íŒŒí‹°í´
      particles: []
    };
    
    // ìº”ë²„ìŠ¤
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // WebSocket
    let ws = null;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function init() {
      resize();
      loadDemoData();
      initParticles();
      connectWebSocket();
      setupEventListeners();
      animate();
    }
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      positionNodes();
    }
    
    function loadDemoData() {
      // Economic Physics Engine ë°ëª¨ ë°ì´í„°
      state.nodes = [
        { id: 'P01', name: 'ì˜¤ì„¸í˜¸', type: 'core', coin: 96154, velocity: 96154, x: 0, y: 0, quantum: 'observed', chaos: 1.2 },
        { id: 'P02', name: 'ê¹€ê²½í¬', type: 'core', coin: 55556, velocity: 55556, x: 0, y: 0, quantum: 'observed', chaos: 1.0 },
        { id: 'P03', name: 'ì˜¤ì„ ìš°', type: 'team', coin: 50000, velocity: 50000, x: 0, y: 0, quantum: 'observed', chaos: 1.1 },
        { id: 'P04', name: 'ì˜¤ì—°ìš°', type: 'team', coin: 41667, velocity: 41667, x: 0, y: 0, quantum: 'superposed', chaos: 0.9 },
        { id: 'P05', name: 'ì˜¤ì€ìš°', type: 'team', coin: 38889, velocity: 38889, x: 0, y: 0, quantum: 'superposed', chaos: 0.8 },
      ];
      
      state.links = [
        { source: 'P01', target: 'P02', value: 28000000, type: 'synergy', phi: 1345336 },
        { source: 'P01', target: 'P03', value: 35000000, type: 'synergy', phi: 599516 },
        { source: 'P02', target: 'P03', value: 45000000, type: 'synergy', phi: 1023411 },
        { source: 'P02', target: 'P04', value: 18000000, type: 'flow', phi: 0 },
        { source: 'P03', target: 'P04', value: 22000000, type: 'flow', phi: 0 },
        { source: 'P04', target: 'P05', value: 15000000, type: 'prediction', phi: 0 },
        { source: 'P01', target: 'P05', value: 20000000, type: 'prediction', phi: 0 },
      ];
      
      positionNodes();
      updateUI();
    }
    
    function positionNodes() {
      const cx = width / 2 + state.pan.x;
      const cy = height / 2 + state.pan.y;
      const radius = Math.min(width, height) * 0.25 * state.scale;
      
      state.nodes.forEach((node, i) => {
        const angle = (i / state.nodes.length) * Math.PI * 2 - Math.PI / 2;
        node.x = cx + Math.cos(angle) * radius;
        node.y = cy + Math.sin(angle) * radius;
      });
    }
    
    function initParticles() {
      state.particles = [];
      
      state.links.forEach(link => {
        const count = Math.min(Math.ceil(link.value / 5000000), 10);
        for (let i = 0; i < count; i++) {
          state.particles.push({
            link: link,
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.003,
            trail: [],
            glow: link.type === 'prediction'
          });
        }
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WebSocket
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function connectWebSocket() {
      try {
        ws = new WebSocket(`ws://${window.location.hostname}:8000/ws`);
        
        ws.onopen = () => {
          document.getElementById('ws-dot').classList.add('connected');
          document.getElementById('ws-status').textContent = 'ì‹¤ì‹œê°„ ì—°ê²°ë¨';
        };
        
        ws.onmessage = (e) => {
          const msg = JSON.parse(e.data);
          handleWSMessage(msg);
        };
        
        ws.onclose = () => {
          document.getElementById('ws-dot').classList.remove('connected');
          document.getElementById('ws-status').textContent = 'ì—°ê²° ëŠê¹€ - ì¬ì—°ê²° ì¤‘...';
          setTimeout(connectWebSocket, 3000);
        };
        
        ws.onerror = () => {
          document.getElementById('ws-status').textContent = 'ë°ëª¨ ëª¨ë“œ';
        };
      } catch (e) {
        document.getElementById('ws-status').textContent = 'ë°ëª¨ ëª¨ë“œ';
      }
    }
    
    function handleWSMessage(msg) {
      if (msg.type === 'STATE_SNAPSHOT') {
        // ì „ì²´ ìƒíƒœ ë¡œë“œ
        console.log('STATE_SNAPSHOT received');
      } else if (msg.type === 'PREDICT_RESULT') {
        // ì˜ˆì¸¡ ê²°ê³¼ ì—…ë°ì´íŠ¸
        if (msg.payload && msg.payload.kpi) {
          state.kpi = msg.payload.kpi;
          updatePrediction();
        }
      }
    }
    
    function sendInput(inputType, params) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'INPUT_APPLY',
          ts: new Date().toISOString(),
          payload: {
            input_type: inputType,
            meta: { industry_id: 'GENERIC', customer_id: 'CUST-001', project_id: 'PROJ-ALPHA' },
            ...params
          }
        }));
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë Œë”ë§
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function render() {
      // ë°°ê²½
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, width, height);
      
      // ê·¸ë¦¬ë“œ
      drawGrid();
      
      // QCF ìƒíƒœì— ë”°ë¥¸ ë Œë”ë§
      if (state.qcfState === 'quantum') {
        renderQuantumState();
      } else if (state.qcfState === 'cluster') {
        renderClusterState();
      } else {
        renderObserveState();
      }
    }
    
    function drawGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      
      const gridSize = 50 * state.scale;
      const offsetX = state.pan.x % gridSize;
      const offsetY = state.pan.y % gridSize;
      
      for (let x = offsetX; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      for (let y = offsetY; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    function renderQuantumState() {
      // ì–‘ì ìƒíƒœ: í¬ë¯¸í•œ í™•ë¥  ë¶„í¬ë§Œ í‘œì‹œ
      ctx.globalAlpha = 0.2;
      
      state.nodes.forEach(node => {
        // í™•ë¥  ë¶„í¬ ì˜¤ë¼
        const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 100);
        gradient.addColorStop(0, 'rgba(153, 102, 255, 0.3)');
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(node.x, node.y, 100, 0, Math.PI * 2);
        ctx.fill();
      });
      
      ctx.globalAlpha = 1;
      
      // ì¤‘ì•™ í…ìŠ¤íŠ¸
      ctx.font = '24px sans-serif';
      ctx.fillStyle = 'rgba(153, 102, 255, 0.5)';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸŒ€ Quantum State - ê´€ì¸¡ ëŒ€ê¸° ì¤‘', width / 2, height / 2);
    }
    
    function renderClusterState() {
      // í´ëŸ¬ìŠ¤í„° ìƒíƒœ: ìš”ì•½ ë…¸ë“œë§Œ í‘œì‹œ
      const clusterNode = {
        x: width / 2,
        y: height / 2,
        size: 80,
        label: `í´ëŸ¬ìŠ¤í„° (${state.nodes.length}ëª…)`,
        value: state.nodes.reduce((sum, n) => sum + n.coin, 0)
      };
      
      // í´ëŸ¬ìŠ¤í„° ë…¸ë“œ
      ctx.beginPath();
      ctx.arc(clusterNode.x, clusterNode.y, clusterNode.size, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(153, 102, 255, 0.3)';
      ctx.fill();
      ctx.strokeStyle = '#9966ff';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // ë¼ë²¨
      ctx.font = 'bold 16px sans-serif';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText(clusterNode.label, clusterNode.x, clusterNode.y - 10);
      ctx.font = '14px sans-serif';
      ctx.fillStyle = '#00ff88';
      ctx.fillText(formatMoney(clusterNode.value) + '/min', clusterNode.x, clusterNode.y + 15);
    }
    
    function renderObserveState() {
      // ê´€ì¸¡ ìƒíƒœ: ì „ì²´ ë Œë”ë§
      
      // ë§í¬ ë Œë”ë§
      state.links.forEach(link => {
        const source = state.nodes.find(n => n.id === link.source);
        const target = state.nodes.find(n => n.id === link.target);
        if (!source || !target) return;
        
        drawLink(source, target, link);
      });
      
      // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ë Œë”ë§
      updateParticles();
      renderParticles();
      
      // ë…¸ë“œ ë Œë”ë§
      state.nodes.forEach(node => {
        drawNode(node);
      });
    }
    
    function drawLink(source, target, link) {
      const midX = (source.x + target.x) / 2;
      const midY = (source.y + target.y) / 2 - 30;
      
      ctx.beginPath();
      ctx.moveTo(source.x, source.y);
      ctx.quadraticCurveTo(midX, midY, target.x, target.y);
      
      // ë§í¬ íƒ€ì…ì— ë”°ë¥¸ ìŠ¤íƒ€ì¼
      if (link.type === 'prediction') {
        ctx.setLineDash([12, 8]);
        ctx.strokeStyle = 'rgba(255, 204, 0, 0.6)';
        ctx.lineWidth = 2;
      } else if (link.type === 'synergy' && link.phi > 0) {
        ctx.setLineDash([]);
        ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + link.phi / 2000000})`;
        ctx.lineWidth = 2 + link.phi / 500000;
      } else {
        ctx.setLineDash([]);
        ctx.strokeStyle = 'rgba(0, 204, 255, 0.3)';
        ctx.lineWidth = 1 + link.value / 20000000;
      }
      
      ctx.stroke();
      ctx.setLineDash([]);
      
      // ì–½í˜ íš¨ê³¼
      if (state.effects.entangle && link.type === 'synergy') {
        drawEntanglementEffect(source, target);
      }
    }
    
    function drawNode(node) {
      const size = 25 + Math.sqrt(node.coin) / 100;
      const isSelected = state.selectedNodes.has(node.id);
      const isDragging = state.dragNode === node;
      
      // ì–‘ì ì¤‘ì²© íš¨ê³¼
      if (state.effects.superposition && node.quantum === 'superposed') {
        drawQuantumSuperposition(node, size);
      }
      
      // ì¹´ì˜¤ìŠ¤ íš¨ê³¼
      let chaosOffset = { x: 0, y: 0 };
      if (state.effects.chaos && node.chaos !== 1) {
        const t = Date.now() / 1000;
        chaosOffset.x = Math.sin(t * 5 + node.x) * (node.chaos - 1) * 5;
        chaosOffset.y = Math.cos(t * 5 + node.y) * (node.chaos - 1) * 5;
      }
      
      const x = node.x + chaosOffset.x;
      const y = node.y + chaosOffset.y;
      
      // ê¸€ë¡œìš°
      if (isDragging || isSelected) {
        ctx.beginPath();
        ctx.arc(x, y, size * 2, 0, Math.PI * 2);
        ctx.fillStyle = isDragging ? 'rgba(255, 204, 0, 0.2)' : 'rgba(0, 204, 255, 0.2)';
        ctx.fill();
      }
      
      // ì™¸ê³½ ê¸€ë¡œìš°
      ctx.beginPath();
      ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = getNodeGlowColor(node);
      ctx.fill();
      
      // ë©”ì¸ ì›
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fillStyle = getNodeColor(node);
      ctx.shadowColor = ctx.fillStyle;
      ctx.shadowBlur = 15;
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // í…Œë‘ë¦¬
      ctx.strokeStyle = isSelected ? '#00ccff' : '#fff';
      ctx.lineWidth = isSelected ? 3 : 2;
      ctx.stroke();
      
      // ì•„ì´ì½˜
      ctx.font = `${size * 0.7}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';
      ctx.fillText(getNodeIcon(node), x, y);
      
      // ì´ë¦„
      ctx.font = 'bold 12px sans-serif';
      ctx.fillStyle = '#fff';
      ctx.fillText(node.name, x, y + size + 14);
      
      // ëˆ (coin)
      ctx.font = '10px sans-serif';
      ctx.fillStyle = '#00ff88';
      ctx.fillText(formatMoneyShort(node.coin) + '/m', x, y - size - 8);
      
      // ì–‘ì ìƒíƒœ í‘œì‹œ
      if (node.quantum === 'superposed') {
        ctx.font = '8px sans-serif';
        ctx.fillStyle = '#9966ff';
        ctx.fillText('ğŸŒ€ superposed', x, y + size + 28);
      }
    }
    
    function drawQuantumSuperposition(node, size) {
      // ì¤‘ì²© ì˜¤ë¼ (ë‹¤ì¤‘ ìƒ‰ìƒ)
      const t = Date.now() / 1000;
      const colors = ['rgba(153, 102, 255, 0.2)', 'rgba(0, 255, 136, 0.2)', 'rgba(255, 204, 0, 0.2)'];
      
      colors.forEach((color, i) => {
        const offset = Math.sin(t * 2 + i * 2) * 10;
        ctx.beginPath();
        ctx.arc(node.x + offset, node.y, size * 2, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      });
    }
    
    function drawEntanglementEffect(source, target) {
      const t = Date.now() / 500;
      const midX = (source.x + target.x) / 2;
      const midY = (source.y + target.y) / 2;
      
      // ì–½í˜ íŒŒí‹°í´
      ctx.beginPath();
      ctx.arc(midX + Math.sin(t) * 10, midY + Math.cos(t) * 10, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#9966ff';
      ctx.shadowColor = '#9966ff';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    function getNodeColor(node) {
      if (node.type === 'core') return '#00ff88';
      if (node.quantum === 'superposed') return '#9966ff';
      return '#00ccff';
    }
    
    function getNodeGlowColor(node) {
      if (node.type === 'core') return 'rgba(0, 255, 136, 0.15)';
      if (node.quantum === 'superposed') return 'rgba(153, 102, 255, 0.15)';
      return 'rgba(0, 204, 255, 0.15)';
    }
    
    function getNodeIcon(node) {
      if (node.type === 'core') return 'ğŸ‘‘';
      if (node.quantum === 'superposed') return 'ğŸŒ€';
      return 'ğŸ‘¤';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // íŒŒí‹°í´
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateParticles() {
      state.particles.forEach(p => {
        p.progress += p.speed;
        if (p.progress > 1) {
          p.progress = 0;
          p.trail = [];
        }
        
        const source = state.nodes.find(n => n.id === p.link.source);
        const target = state.nodes.find(n => n.id === p.link.target);
        if (!source || !target) return;
        
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2 - 30;
        
        const t = p.progress;
        p.x = Math.pow(1-t, 2) * source.x + 2 * (1-t) * t * midX + Math.pow(t, 2) * target.x;
        p.y = Math.pow(1-t, 2) * source.y + 2 * (1-t) * t * midY + Math.pow(t, 2) * target.y;
        
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 15) p.trail.shift();
      });
    }
    
    function renderParticles() {
      state.particles.forEach(p => {
        if (!p.x || !p.y) return;
        
        // íŠ¸ë ˆì¼
        if (p.trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          
          const color = p.glow ? '#ffcc00' : '#00ff88';
          const gradient = ctx.createLinearGradient(p.trail[0].x, p.trail[0].y, p.x, p.y);
          gradient.addColorStop(0, 'transparent');
          gradient.addColorStop(1, color);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.glow ? 3 : 2;
          ctx.stroke();
        }
        
        // íŒŒí‹°í´
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.glow ? 4 : 3, 0, Math.PI * 2);
        ctx.fillStyle = p.glow ? '#ffcc00' : '#00ff88';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function setupEventListeners() {
      // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('click', onClick);
      canvas.addEventListener('wheel', onWheel);
      
      // QCF ìƒíƒœ ë²„íŠ¼
      document.querySelectorAll('.state-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.state-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          state.qcfState = btn.dataset.state;
          document.getElementById('qcf-state-text').textContent = state.qcfState.toUpperCase();
          updateZoomInfo();
        });
      });
      
      // ë¬¼ë¦¬ íš¨ê³¼ í† ê¸€
      document.querySelectorAll('.physics-effect').forEach(el => {
        el.addEventListener('click', () => {
          el.classList.toggle('active');
          const effect = el.dataset.effect;
          state.effects[effect] = !state.effects[effect];
        });
      });
      
      // ì…ë ¥ íƒ€ì… ë²„íŠ¼
      document.querySelectorAll('.input-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.input-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          state.inputType = btn.dataset.input;
          updateInputHint();
        });
      });
      
      // ì•¡ì…˜ ë²„íŠ¼
      document.getElementById('btn-select').addEventListener('click', toggleSelectMode);
      document.getElementById('btn-group').addEventListener('click', createGroup);
      document.getElementById('btn-ungroup').addEventListener('click', ungroupSelected);
      document.getElementById('btn-delete').addEventListener('click', deleteSelected);
      document.getElementById('btn-automate').addEventListener('click', automateSelected);
      
      // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
      window.addEventListener('resize', resize);
    }
    
    function getNodeAt(x, y) {
      for (const node of state.nodes) {
        const size = 25 + Math.sqrt(node.coin) / 100;
        const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
        if (dist < size * 1.5) return node;
      }
      return null;
    }
    
    function onMouseDown(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      
      if (state.isSelecting) {
        state.selectionStart = { x: e.clientX, y: e.clientY };
        canvas.classList.add('selecting');
      } else if (node) {
        state.isDragging = true;
        state.dragNode = node;
        state.dragStart = { x: e.clientX, y: e.clientY };
        canvas.classList.add('dragging');
      }
    }
    
    function onMouseMove(e) {
      if (state.isDragging && state.dragNode) {
        state.dragNode.x = e.clientX;
        state.dragNode.y = e.clientY;
      } else if (state.isSelecting && state.selectionStart) {
        drawSelectionBox(e.clientX, e.clientY);
      }
    }
    
    function onMouseUp(e) {
      if (state.isDragging && state.dragNode) {
        const dx = e.clientX - state.dragStart.x;
        const dy = e.clientY - state.dragStart.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 10) {
          handleDragInput(state.dragNode, distance, dx, dy);
        }
        
        state.dragNode = null;
      } else if (state.isSelecting && state.selectionStart) {
        selectNodesInBox(e.clientX, e.clientY);
        hideSelectionBox();
        state.selectionStart = null;
      }
      
      state.isDragging = false;
      canvas.classList.remove('dragging');
      canvas.classList.remove('selecting');
    }
    
    function onClick(e) {
      const node = getNodeAt(e.clientX, e.clientY);
      
      if (node) {
        if (e.shiftKey) {
          // Shift+í´ë¦­: ì„ íƒ í† ê¸€
          if (state.selectedNodes.has(node.id)) {
            state.selectedNodes.delete(node.id);
          } else {
            state.selectedNodes.add(node.id);
          }
        } else {
          showNodePopup(node, e.clientX, e.clientY);
        }
      } else {
        hideNodePopup();
        if (!e.shiftKey) {
          state.selectedNodes.clear();
        }
      }
    }
    
    function onWheel(e) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      state.scale = Math.max(0.3, Math.min(3, state.scale * delta));
      
      // ì¤Œ ë ˆë²¨ ì—…ë°ì´íŠ¸
      if (state.scale < 0.5) {
        state.zoom = 1;
      } else if (state.scale < 1) {
        state.zoom = 2;
      } else {
        state.zoom = 3;
      }
      
      updateZoomInfo();
      positionNodes();
    }
    
    function handleDragInput(node, distance, dx, dy) {
      if (state.inputType === 'swap') {
        // ê°€ì¥ ê°€ê¹Œìš´ ë‹¤ë¥¸ ë…¸ë“œ ì°¾ê¸°
        let closest = null;
        let minDist = Infinity;
        
        state.nodes.forEach(n => {
          if (n !== node) {
            const d = Math.sqrt(Math.pow(n.x - node.x, 2) + Math.pow(n.y - node.y, 2));
            if (d < minDist) {
              minDist = d;
              closest = n;
            }
          }
        });
        
        if (closest && minDist < 150) {
          sendInput('SWAP', {
            swap: { out: node.id, in: closest.id }
          });
          
          // ì‹œë®¬ë ˆì´ì…˜ í”¼ë“œë°±
          showFeedback(`SWAP: ${node.name} â†’ ${closest.name}`);
        }
      } else if (state.inputType === 'alloc') {
        const deltaMinutes = distance * 2;
        
        sendInput('ALLOC', {
          alloc: [{ person_id: node.id, delta_minutes: deltaMinutes }]
        });
        
        showFeedback(`ALLOC: ${node.name} +${Math.round(deltaMinutes)}ë¶„`);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì„ íƒ / ê·¸ë£¹
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function toggleSelectMode() {
      state.isSelecting = !state.isSelecting;
      document.getElementById('btn-select').classList.toggle('active', state.isSelecting);
      canvas.style.cursor = state.isSelecting ? 'crosshair' : 'grab';
    }
    
    function drawSelectionBox(x, y) {
      const box = document.getElementById('selection-box');
      const left = Math.min(state.selectionStart.x, x);
      const top = Math.min(state.selectionStart.y, y);
      const w = Math.abs(x - state.selectionStart.x);
      const h = Math.abs(y - state.selectionStart.y);
      
      box.style.display = 'block';
      box.style.left = left + 'px';
      box.style.top = top + 'px';
      box.style.width = w + 'px';
      box.style.height = h + 'px';
    }
    
    function hideSelectionBox() {
      document.getElementById('selection-box').style.display = 'none';
    }
    
    function selectNodesInBox(x, y) {
      const left = Math.min(state.selectionStart.x, x);
      const right = Math.max(state.selectionStart.x, x);
      const top = Math.min(state.selectionStart.y, y);
      const bottom = Math.max(state.selectionStart.y, y);
      
      state.nodes.forEach(node => {
        if (node.x >= left && node.x <= right && node.y >= top && node.y <= bottom) {
          state.selectedNodes.add(node.id);
        }
      });
    }
    
    function createGroup() {
      if (state.selectedNodes.size < 2) {
        showFeedback('2ê°œ ì´ìƒ ë…¸ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”');
        return;
      }
      
      const groupId = 'G' + Date.now();
      const members = Array.from(state.selectedNodes);
      
      state.clusters.push({
        id: groupId,
        members: members,
        label: `í´ëŸ¬ìŠ¤í„° ${state.clusters.length + 1}`
      });
      
      showFeedback(`ê·¸ë£¹ ìƒì„±: ${members.length}ëª…`);
      state.selectedNodes.clear();
    }
    
    function ungroupSelected() {
      showFeedback('ê·¸ë£¹ í•´ì œ');
    }
    
    function deleteSelected() {
      if (state.selectedNodes.size === 0) {
        showFeedback('ë…¸ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”');
        return;
      }
      
      state.nodes = state.nodes.filter(n => !state.selectedNodes.has(n.id));
      state.links = state.links.filter(l => 
        !state.selectedNodes.has(l.source) && !state.selectedNodes.has(l.target)
      );
      
      showFeedback(`CUT: ${state.selectedNodes.size}ê°œ ì‚­ì œ`);
      state.selectedNodes.clear();
      initParticles();
    }
    
    function automateSelected() {
      showFeedback('LINK: ì‹œë„ˆì§€ ìë™í™” ì‹œì‘');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UI ì—…ë°ì´íŠ¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function updateUI() {
      document.getElementById('kpi-net').textContent = formatMoney(state.kpi.net_7d_pred);
      document.getElementById('kpi-entropy').textContent = state.kpi.entropy_7d_pred.toFixed(2);
      document.getElementById('kpi-velocity').textContent = formatMoney(state.kpi.velocity_7d_pred) + '/m';
      document.getElementById('kpi-nodes').textContent = state.nodes.length;
      
      document.getElementById('loaded-nodes').textContent = state.nodes.length;
      document.getElementById('loaded-links').textContent = state.links.length;
      
      updatePrediction();
      updateZoomInfo();
    }
    
    function updatePrediction() {
      document.getElementById('pred-net').textContent = formatMoney(state.kpi.net_7d_pred);
      document.getElementById('pred-entropy').textContent = state.kpi.entropy_7d_pred.toFixed(2);
      document.getElementById('pred-score').textContent = formatMoney(state.kpi.best_team_score);
      
      const teamEl = document.getElementById('pred-team');
      teamEl.innerHTML = state.kpi.best_team.map(name => 
        `<span class="team-badge">${name}</span>`
      ).join('');
    }
    
    function updateZoomInfo() {
      const levels = {
        1: { name: 'Level 1', desc: 'êµ­ê°€ ë ˆë²¨ (í´ëŸ¬ìŠ¤í„°)' },
        2: { name: 'Level 2', desc: 'ë„ì‹œ ë ˆë²¨ (ê·¸ë£¹)' },
        3: { name: 'Level 3', desc: 'ê°œì¸ ë ˆë²¨ (1-30 ë…¸ë“œ)' }
      };
      
      const level = levels[state.zoom];
      document.getElementById('zoom-value').textContent = level.name;
      document.getElementById('zoom-level').textContent = level.desc;
    }
    
    function updateInputHint() {
      const hints = {
        swap: 'ë…¸ë“œë¥¼ ë“œë˜ê·¸í•˜ì—¬ íŒ€ êµì²´.\në“œë˜ê·¸ ê±°ë¦¬ = ë¬¼ë¦¬ ì…ë ¥ í¬ê¸°.\nì˜ˆì¸¡ ì¦‰ì‹œ ê°±ì‹  (1ì´ˆ ë‚´).',
        alloc: 'ë…¸ë“œë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì‹œê°„ ë°°ë¶„.\në“œë˜ê·¸ ê±°ë¦¬ = Î”Minutes.\nVelocity ë³€í™” ì˜ˆì¸¡.',
        group: 'Shift+í´ë¦­ ë˜ëŠ” ì„ íƒ ëª¨ë“œë¡œ\nì—¬ëŸ¬ ë…¸ë“œ ì„ íƒ í›„ ê·¸ë£¹ ìƒì„±.'
      };
      
      document.getElementById('input-hint').textContent = hints[state.inputType];
    }
    
    function showNodePopup(node, x, y) {
      const popup = document.getElementById('node-popup');
      
      document.getElementById('popup-name').textContent = node.name;
      document.getElementById('popup-type').textContent = node.type;
      document.getElementById('popup-coin').textContent = formatMoney(node.coin) + '/min';
      document.getElementById('popup-velocity').textContent = formatMoney(node.velocity) + '/min';
      document.getElementById('popup-quantum').textContent = node.quantum;
      document.getElementById('popup-chaos').textContent = node.chaos.toFixed(1) + 'x';
      
      const linkCount = state.links.filter(l => 
        l.source === node.id || l.target === node.id
      ).length;
      document.getElementById('popup-links').textContent = linkCount;
      
      popup.style.left = Math.min(x + 20, width - 250) + 'px';
      popup.style.top = Math.min(y + 20, height - 300) + 'px';
      popup.classList.add('visible');
    }
    
    function hideNodePopup() {
      document.getElementById('node-popup').classList.remove('visible');
    }
    
    function showFeedback(message) {
      console.log('Feedback:', message);
      // ê°„ë‹¨í•œ í”¼ë“œë°± (ë‚˜ì¤‘ì— í† ìŠ¤íŠ¸ë¡œ ëŒ€ì²´)
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (!value) return 'â‚©0';
      if (Math.abs(value) >= 100000000) return 'â‚©' + (value / 100000000).toFixed(1) + 'ì–µ';
      if (Math.abs(value) >= 1000000) return 'â‚©' + (value / 1000000).toFixed(0) + 'M';
      if (Math.abs(value) >= 10000) return 'â‚©' + Math.round(value / 10000) + 'ë§Œ';
      return 'â‚©' + Math.round(value).toLocaleString();
    }
    
    function formatMoneyShort(value) {
      if (!value) return '0';
      if (Math.abs(value) >= 100000) return (value / 10000).toFixed(0) + 'ë§Œ';
      return Math.round(value).toLocaleString();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function animate() {
      render();
      requestAnimationFrame(animate);
    }
    
    // ì‹œì‘
    init();
    
    console.log('âš›ï¸ AUTUS Economic Physics Engine - QCF Edition initialized');
  </script>
</body>
</html>
