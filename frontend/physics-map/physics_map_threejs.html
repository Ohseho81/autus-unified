<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ® AUTUS Physics Map - Three.js 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #000; 
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    
    #container { width: 100%; height: 100vh; }
    
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 0%, transparent 100%);
      padding: 24px 32px;
      z-index: 100;
    }
    
    .header h1 {
      color: #fff;
      font-size: 22px;
      font-weight: 600;
    }
    
    .header p {
      color: #666;
      font-size: 11px;
      margin-top: 6px;
    }
    
    .stats {
      position: absolute;
      top: 24px;
      right: 32px;
      display: flex;
      gap: 30px;
      z-index: 100;
    }
    
    .stat { text-align: right; }
    .stat-label { color: #555; font-size: 10px; text-transform: uppercase; }
    .stat-value { font-size: 20px; font-weight: bold; margin-top: 4px; }
    .green { color: #00ff88; text-shadow: 0 0 15px rgba(0, 255, 136, 0.6); }
    .cyan { color: #00ccff; text-shadow: 0 0 15px rgba(0, 204, 255, 0.6); }
    .gold { color: #ffcc00; text-shadow: 0 0 15px rgba(255, 204, 0, 0.6); }
    
    .info-panel {
      position: absolute;
      top: 100px;
      left: 32px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(0, 204, 255, 0.3);
      border-radius: 12px;
      padding: 20px;
      min-width: 280px;
      z-index: 100;
      display: none;
    }
    
    .info-panel.visible { display: block; }
    
    .info-panel h3 {
      color: #fff;
      font-size: 18px;
      margin-bottom: 12px;
    }
    
    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 13px;
    }
    
    .info-row-label { color: #666; }
    .info-row-value { font-weight: bold; color: #fff; }
    
    .controls {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
    }
    
    .control-btn {
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(0, 204, 255, 0.4);
      border-radius: 25px;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .control-btn:hover {
      background: rgba(0, 204, 255, 0.2);
      border-color: #00ccff;
    }
    
    .footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(0deg, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
      padding: 20px 32px;
      font-size: 10px;
      color: #444;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <div class="header">
    <h1>ğŸ® AUTUS Physics Map - Three.js 3D</h1>
    <p>3D Force-Directed Graph â€¢ ë“œë˜ê·¸ë¡œ íšŒì „ â€¢ ìŠ¤í¬ë¡¤ë¡œ ì¤Œ</p>
  </div>
  
  <div class="stats">
    <div class="stat">
      <div class="stat-label">Total Value</div>
      <div class="stat-value green">â‚©7.09ì–µ</div>
    </div>
    <div class="stat">
      <div class="stat-label">Synergy</div>
      <div class="stat-value cyan">â‚©2,281ë§Œ</div>
    </div>
    <div class="stat">
      <div class="stat-label">12M Forecast</div>
      <div class="stat-value gold">â‚©8.08ì–µ</div>
    </div>
  </div>
  
  <div class="info-panel" id="info-panel">
    <h3 id="info-name">-</h3>
    <div class="info-row">
      <span class="info-row-label">Role</span>
      <span class="info-row-value" id="info-role">-</span>
    </div>
    <div class="info-row">
      <span class="info-row-label">Value</span>
      <span class="info-row-value green" id="info-value">â‚©0</span>
    </div>
    <div class="info-row">
      <span class="info-row-label">Synergy</span>
      <span class="info-row-value cyan" id="info-synergy">â‚©0</span>
    </div>
  </div>
  
  <div class="controls">
    <button class="control-btn" id="btn-reset">ğŸ”„ ë¦¬ì…‹</button>
    <button class="control-btn" id="btn-animate">âœ¨ ì• ë‹ˆë©”ì´ì…˜</button>
    <button class="control-btn" id="btn-labels">ğŸ·ï¸ ë¼ë²¨</button>
  </div>
  
  <div class="footer">
    ğŸ–±ï¸ ë“œë˜ê·¸: íšŒì „ | ìŠ¤í¬ë¡¤: ì¤Œ | ë…¸ë“œ í´ë¦­: ìƒì„¸ ì •ë³´ | V = D - T + S
  </div>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUTUS Physics Map ë°ì´í„°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const nodes = [
      { id: 'ë‹¹ì‹ ', label: 'ëŒ€í‘œ', value: 182886563, color: 0x00ff88, x: 0, y: 0, z: 0 },
      { id: 'ë§¤ë‹ˆì €', label: 'ë§¤ë‹ˆì €', value: 75000000, color: 0x00ccff, x: 30, y: 15, z: 10 },
      { id: 'í—¤ë“œì½”ì¹˜', label: 'í—¤ë“œì½”ì¹˜', value: 68000000, color: 0x00ccff, x: 30, y: -15, z: -10 },
      { id: 'í•™ìƒêµ°', label: 'í•™ìƒêµ°', value: 55000000, color: 0xffcc00, x: 50, y: 0, z: 20 },
      { id: 'í•™ë¶€ëª¨êµ°', label: 'í•™ë¶€ëª¨êµ°', value: 120000000, color: 0xff6600, x: -30, y: 20, z: 0 },
      { id: 'íŒŒíŠ¸ë„ˆA', label: 'ë¯¸êµ­', value: 50000000, color: 0x9966ff, x: -40, y: -20, z: -20 },
      { id: 'ê³ ê°B', label: 'ì¼ë³¸', value: 35000000, color: 0x00ccff, x: 40, y: 30, z: -15 },
      { id: 'ìŠ¤í°ì„œC', label: 'ì‚¬ìš°ë””', value: 0, forecast: 500000000, color: 0xffcc00, x: -50, y: 0, z: 30 }
    ];
    
    const links = [
      { from: 'í•™ë¶€ëª¨êµ°', to: 'ë‹¹ì‹ ', value: 120000000, type: 'inflow' },
      { from: 'ë‹¹ì‹ ', to: 'ë§¤ë‹ˆì €', value: 25000000, type: 'inflow' },
      { from: 'ë‹¹ì‹ ', to: 'í—¤ë“œì½”ì¹˜', value: 23000000, type: 'inflow' },
      { from: 'ë§¤ë‹ˆì €', to: 'í—¤ë“œì½”ì¹˜', value: 11406562, type: 'synergy' },
      { from: 'í—¤ë“œì½”ì¹˜', to: 'í•™ìƒêµ°', value: 8000000, type: 'synergy' },
      { from: 'ê³ ê°B', to: 'ë‹¹ì‹ ', value: 35000000, type: 'inflow' },
      { from: 'ë‹¹ì‹ ', to: 'íŒŒíŠ¸ë„ˆA', value: 15000000, type: 'outflow' },
      { from: 'ë‹¹ì‹ ', to: 'ìŠ¤í°ì„œC', value: 100000000, type: 'prediction' }
    ];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Three.js ì´ˆê¸°í™”
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);
    
    // CSS2D ë Œë”ëŸ¬ (ë¼ë²¨ìš©)
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    container.appendChild(labelRenderer.domElement);
    
    // OrbitControls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    camera.position.set(0, 0, 100);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë°°ê²½ (ë³„/ì€í•˜)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 5000;
    const starPositions = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount * 3; i += 3) {
      starPositions[i] = (Math.random() - 0.5) * 2000;
      starPositions[i + 1] = (Math.random() - 0.5) * 2000;
      starPositions[i + 2] = (Math.random() - 0.5) * 2000;
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë…¸ë“œ ìƒì„±
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const nodeMeshes = [];
    let showLabels = true;
    
    nodes.forEach(node => {
      const size = Math.max(3, Math.sqrt(node.value || node.forecast) / 3000);
      
      // ê¸€ë¡œìš° (ì™¸ë¶€ êµ¬)
      const glowGeometry = new THREE.SphereGeometry(size * 1.5, 32, 32);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: node.color,
        transparent: true,
        opacity: 0.2
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.set(node.x, node.y, node.z);
      scene.add(glow);
      
      // ë©”ì¸ ë…¸ë“œ
      const geometry = new THREE.SphereGeometry(size, 32, 32);
      const material = new THREE.MeshBasicMaterial({
        color: node.color,
        transparent: true,
        opacity: 0.9
      });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(node.x, node.y, node.z);
      sphere.userData = node;
      scene.add(sphere);
      nodeMeshes.push(sphere);
      
      // ë¼ë²¨
      const labelDiv = document.createElement('div');
      labelDiv.className = 'label';
      labelDiv.textContent = node.id;
      labelDiv.style.cssText = `
        color: #fff;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.7);
        padding: 4px 8px;
        border-radius: 4px;
        pointer-events: none;
      `;
      
      const label = new CSS2DObject(labelDiv);
      label.position.set(0, size + 2, 0);
      sphere.add(label);
      node.label3d = label;
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ë§í¬ (ëˆ íë¦„) ìƒì„±
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    links.forEach(link => {
      const fromNode = nodes.find(n => n.id === link.from);
      const toNode = nodes.find(n => n.id === link.to);
      if (!fromNode || !toNode) return;
      
      // ê³¡ì„  ìƒì„±
      const midPoint = new THREE.Vector3(
        (fromNode.x + toNode.x) / 2,
        (fromNode.y + toNode.y) / 2 + 15,
        (fromNode.z + toNode.z) / 2
      );
      
      const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(fromNode.x, fromNode.y, fromNode.z),
        midPoint,
        new THREE.Vector3(toNode.x, toNode.y, toNode.z)
      );
      
      const points = curve.getPoints(50);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      
      // ìƒ‰ìƒ
      let color;
      if (link.type === 'inflow') color = 0x00ff88;
      else if (link.type === 'outflow') color = 0xff4466;
      else if (link.type === 'synergy') color = 0x9966ff;
      else if (link.type === 'prediction') color = 0xffcc00;
      
      const material = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: link.type === 'prediction' ? 0.5 : 0.7
      });
      
      const line = new THREE.Line(geometry, material);
      scene.add(line);
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // íŒŒí‹°í´ ì‹œìŠ¤í…œ (ë³„ë˜¥ë³„)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const particleCount = 500;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleColors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount * 3; i += 3) {
      particlePositions[i] = (Math.random() - 0.5) * 200;
      particlePositions[i + 1] = (Math.random() - 0.5) * 200;
      particlePositions[i + 2] = (Math.random() - 0.5) * 200;
      
      // ëœë¤ ìƒ‰ìƒ (ì´ˆë¡/ì‹œì•ˆ/ì£¼í™©)
      const colorChoice = Math.random();
      if (colorChoice < 0.33) {
        particleColors[i] = 0; particleColors[i + 1] = 1; particleColors[i + 2] = 0.5;
      } else if (colorChoice < 0.66) {
        particleColors[i] = 0; particleColors[i + 1] = 0.8; particleColors[i + 2] = 1;
      } else {
        particleColors[i] = 1; particleColors[i + 1] = 0.8; particleColors[i + 2] = 0;
      }
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      size: 1,
      vertexColors: true,
      transparent: true,
      opacity: 0.8
    });
    
    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particleSystem);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì´ë²¤íŠ¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', onClick);
    
    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodeMeshes);
      
      if (intersects.length > 0) {
        const node = intersects[0].object.userData;
        showNodeInfo(node);
      } else {
        document.getElementById('info-panel').classList.remove('visible');
      }
    }
    
    function showNodeInfo(node) {
      document.getElementById('info-panel').classList.add('visible');
      document.getElementById('info-name').textContent = `${node.id} (${node.label})`;
      document.getElementById('info-role').textContent = node.label;
      document.getElementById('info-value').textContent = formatMoney(node.value || node.forecast);
      document.getElementById('info-synergy').textContent = formatMoney(node.synergy || 0);
    }
    
    // ì»¨íŠ¸ë¡¤ ë²„íŠ¼
    let isAnimating = true;
    
    document.getElementById('btn-reset').addEventListener('click', () => {
      camera.position.set(0, 0, 100);
      controls.reset();
    });
    
    document.getElementById('btn-animate').addEventListener('click', function() {
      isAnimating = !isAnimating;
      this.textContent = isAnimating ? 'âœ¨ ì• ë‹ˆë©”ì´ì…˜ ON' : 'âœ¨ ì• ë‹ˆë©”ì´ì…˜ OFF';
    });
    
    document.getElementById('btn-labels').addEventListener('click', function() {
      showLabels = !showLabels;
      nodes.forEach(node => {
        if (node.label3d) {
          node.label3d.visible = showLabels;
        }
      });
      this.textContent = showLabels ? 'ğŸ·ï¸ ë¼ë²¨ ON' : 'ğŸ·ï¸ ë¼ë²¨ OFF';
    });
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      time += 0.01;
      
      if (isAnimating) {
        // íŒŒí‹°í´ ì›€ì§ì„
        const positions = particleSystem.geometry.attributes.position.array;
        for (let i = 0; i < particleCount * 3; i += 3) {
          positions[i + 1] += Math.sin(time + i) * 0.1;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
        
        // ë³„ íšŒì „
        stars.rotation.y += 0.0001;
        
        // ë…¸ë“œ í„ìŠ¤
        nodeMeshes.forEach((mesh, i) => {
          const scale = 1 + Math.sin(time * 2 + i) * 0.05;
          mesh.scale.setScalar(scale);
        });
      }
      
      controls.update();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
    
    animate();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ìœ í‹¸ë¦¬í‹°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function formatMoney(value) {
      if (Math.abs(value) >= 100000000) return 'â‚©' + (value / 100000000).toFixed(2) + 'ì–µ';
      if (Math.abs(value) >= 10000) return 'â‚©' + Math.round(value / 10000).toLocaleString() + 'ë§Œ';
      return 'â‚©' + value.toLocaleString();
    }
    
    console.log('ğŸ® AUTUS Physics Map - Three.js 3D initialized');
  </script>
</body>
</html>
